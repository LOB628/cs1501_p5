package cs1501_p5;

import java.util.Map;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;

public class BucketingMapGenerator implements ColorMapGenerator_Inter {
    /**
     * Produces an initial palette. For bucketing implementations, the initial
     * palette will be the centers of the evenly-divided buckets. For clustering
     * implementations, the initial palette will be the initial centroids. When
     * needed, a distance metric should be specified when the color map
     * generator is constructed.
     *
     * @param pixelArray the 2D Pixel array that represents a bitmap image
     * @param numColors  the number of desired colors in the palette
     * @return a Pixel array containing numColors elements
     */
    private static final int colorSpace = 1 << 24;

    @Override
    public Pixel[] generateColorPalette(Pixel[][] pixelArray, int numColors) {
        double increment = (double) colorSpace / (double) numColors;
        Pixel[] palette = new Pixel[numColors];
        double base = increment / 2.0;
        for (int i = 0; i < numColors; i++) {

            palette[i] = utils.intToPixel((int) (base + (double) (i) * increment));

        }

        return palette;
    }

    /**
     * Computes the reduced color map. For bucketing implementations, this will
     * map each color to the center of its bucket. For clustering
     * implementations, this will map each color to its final centroid. When
     * needed, a distance metric should be specified when the color map
     * generator is constructed.
     *
     * @param pixelArray          the pixels array that represents a bitmap image
     * @param initialColorPalette an initial color palette, such as those
     *                            generated by generateColorPalette, represented as
     *                            an array of Pixels
     * @return A Map that maps each distinct color in pixelArray to a final
     *         color
     */
    // @Override
    // public Map<Pixel, Pixel> generateColorMap(Pixel[][] pixelArray, Pixel[]
    // initialColorPalette) {
    // // initialColorPalette can only take inputs from generateColorPalette
    // int[] palette = new int[initialColorPalette.length];
    // for (int i = 0; i < initialColorPalette.length; i++) {
    // palette[i] = utils.pixelToInt(initialColorPalette[i]);
    // }
    // Arrays.sort(palette);
    // HashSet<Pixel> colors = utils.uniqueColorsSet(pixelArray);
    // HashMap<Pixel, Pixel> map = new HashMap<Pixel, Pixel>();
    // boolean flag;
    // for (Pixel color : colors) {
    // int colorInt = utils.pixelToInt(color);
    // flag = false;
    // int upperBound = 0;
    // // O(k) instead of O(log(k))
    // for (int i = 0; i < initialColorPalette.length; i++) {
    // int lowerBound = upperBound;// just use the previous
    // upperBound = i == initialColorPalette.length - 1 ? colorSpace
    // : palette[i] + (palette[i + 1] - palette[i]) / 2;

    // if (colorInt >= lowerBound && colorInt < upperBound) {
    // map.put(color, initialColorPalette[i]);
    // flag = true;
    // break;
    // }
    // }
    // if (!flag) {
    // System.out.println("BUCKET FAILURE");
    // }
    // }

    // return map;
    // }

    @Override
    public Map<Pixel, Pixel> generateColorMap(Pixel[][] pixelArray, Pixel[] initialColorPalette) {
        int numColors = initialColorPalette.length;
        double increment = (double) colorSpace / numColors;
        HashMap<Pixel, Pixel> map = new HashMap<Pixel, Pixel>();
        for (int i = 0; i < pixelArray.length; i++) {
            for (int j = 0; j < pixelArray[0].length; j++) {
                Pixel p = pixelArray[i][j];
                int curColor = utils.pixelToInt(p);
                int bucket = (int) (((double) curColor) / increment);
                Pixel newColor = initialColorPalette[bucket];
                map.put(p, newColor);
            }
        }
        return map;
    }
}
